要理解闭包，首先要理解 JavaScript 的变量作用域。变量的作用域无非就两种：全局变量和局部变量。特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，实际上声明的是一个全局变量！那么有时候需要获取到函数内部的局部变量，可以在函数内部，再定义一个函数，这也是链式作用域结构（作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条）。既然内部函数可以读取外部函数的局部变量，那么把内部函数作为返回值，就可以读取外部函数的内部变量了。

简而言之，**闭包就是能够读取其他函数内部变量的函数**，且访问的变量不会销毁。

```js
function Closure () {
  let num = 0;
  return function innerfunc() {
    num++;
    return num;
  }
}
const Closuree = Closure();
Closuree(); // 1
Closuree(); // 2
console.log(Closuree()) // 3
```

闭包作用在于隐藏变量，避免全局污染；可以读取函数内部的变量。同时闭包使用不当，优点就变成了缺点：导致变量不会被垃圾回收机制回收，造成内存消耗；不恰当的使用闭包可能会造成内存泄漏的问题。

JS 垃圾回收机制即规定在一个函数作用域内，程序执行完以后变量就会被销毁，这样可节省内存；使用闭包时，按照作用域链的特点，闭包（函数）外面的变量不会被销毁，因为函数会一直被调用，所以一直存在，如果闭包使用过多会造成内存销毁。

```js
// 闭包应用
// 实现变量 a 自增
var a = 10;
function Add(){
    a++;
    console.log(a);
}
Add();
Add();
Add();
// 定义一个不污染全局的局部变量,但是实现不了递增
var a = 10;
function Add2(){
    var a = 10;
    a++;
    console.log(a);
}
Add2();
Add2();
Add2();
console.log(a);
// 通过闭包,可以是函数内部局部变量递增,不会影响全部变量
var a = 10;
function Add3(){
    var a = 10;
    return function(){
        a++;
        return a;
    };
};
var cc =  Add3();
console.log(cc());
console.log(cc());
console.log(cc());
console.log(a);
```

